<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaScript," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="ES6语法阮一峰ES6入门教程学习笔记主要是梳理知识点，具体实例分析可以看教程。顺序可能有打乱，我是综合（教程+我认为更重要的章节）的顺序来的。">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6学习笔记">
<meta property="og:url" content="http://yoursite.com/2017/04/26/ES6/index.html">
<meta property="og:site_name" content="ZhangXinyu's Blog">
<meta property="og:description" content="ES6语法阮一峰ES6入门教程学习笔记主要是梳理知识点，具体实例分析可以看教程。顺序可能有打乱，我是综合（教程+我认为更重要的章节）的顺序来的。">
<meta property="og:updated_time" content="2017-06-08T12:19:43.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6学习笔记">
<meta name="twitter:description" content="ES6语法阮一峰ES6入门教程学习笔记主要是梳理知识点，具体实例分析可以看教程。顺序可能有打乱，我是综合（教程+我认为更重要的章节）的顺序来的。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/04/26/ES6/"/>





  <title> ES6学习笔记 | ZhangXinyu's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7fe473d7596c476c8be1be7acfa6c517";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhangXinyu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            时间轴
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/26/ES6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang Xinyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/upload/image/zxy.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangXinyu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ES6学习笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-26T16:19:07+08:00">
                2017-04-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2017-06-08T20:19:43+08:00">
                2017-06-08
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2017/04/26/ES6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/04/26/ES6/" class="leancloud_visitors" data-flag-title="ES6学习笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h1><p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">阮一峰ES6入门教程</a>学习笔记<br>主要是梳理知识点，具体实例分析可以看教程。<br>顺序可能有打乱，我是综合（教程+我认为更重要的章节）的顺序来的。</p>
<a id="more"></a>
<h2 id="let-amp-const命令"><a href="#let-amp-const命令" class="headerlink" title="let &amp; const命令"></a>let &amp; const命令</h2><h3 id="1-let命令"><a href="#1-let命令" class="headerlink" title="1. let命令"></a>1. let命令</h3><h4 id="1-1-基本用法"><a href="#1-1-基本用法" class="headerlink" title="1.1 基本用法"></a>1.1 基本用法</h4><p><code>let</code>声明的变量，只在let命令所在代码块内有效。<br>适用于<code>for</code>循环计数器。<br><code>for</code>循环的循环计数器语句部分和循环体内部是两个作用域。</p>
<h4 id="1-2-不存在变量提升"><a href="#1-2-不存在变量提升" class="headerlink" title="1.2 不存在变量提升"></a>1.2 不存在变量提升</h4><p><code>var</code>存在变量提升，变量在声明前被访问，值为<code>undefined</code>，而<code>let</code>声明前访问会报错。</p>
<h4 id="1-3-暂时性死区-TDZ-Temporal-Dead-Zone"><a href="#1-3-暂时性死区-TDZ-Temporal-Dead-Zone" class="headerlink" title="1.3 暂时性死区(TDZ, Temporal Dead Zone)"></a>1.3 暂时性死区(TDZ, Temporal Dead Zone)</h4><p>如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，包括使用<code>typeof</code>，都会报错。</p>
<h4 id="1-4-不允许重复声明"><a href="#1-4-不允许重复声明" class="headerlink" title="1.4 不允许重复声明"></a>1.4 不允许重复声明</h4><p>在相同作用域内，不能用<code>let</code>重复声明同一个变量；所以不能在函数内部重新声明参数。</p>
<h3 id="2-块级作用域"><a href="#2-块级作用域" class="headerlink" title="2. 块级作用域"></a>2. 块级作用域</h3><h4 id="2-1-为什么需要块级作用域"><a href="#2-1-为什么需要块级作用域" class="headerlink" title="2.1 为什么需要块级作用域"></a>2.1 为什么需要块级作用域</h4><p>内层变量可能会覆盖外层变量<br><code>for</code>循环计数器变量会泄露为全局变量</p>
<h4 id="2-2-let为ES6新增块级作用域"><a href="#2-2-let为ES6新增块级作用域" class="headerlink" title="2.2 let为ES6新增块级作用域"></a>2.2 let为ES6新增块级作用域</h4><ul>
<li>块级作用域可以嵌套</li>
<li>内层作用域可以定义外层作用域的同名变量。<br>这和上面说的“不能在函数重新声明参数”不同，后者是因为参数是在函数体作用域的，如果再声明，就是在同一作用域内重复声明，是不允许的，而这里是不同层次的作用域，不是重复声明，而是覆盖。</li>
<li>IIFE可以使用块级作用域代替<h4 id="2-3-关于在块级作用域内声明函数"><a href="#2-3-关于在块级作用域内声明函数" class="headerlink" title="2.3 关于在块级作用域内声明函数"></a>2.3 关于在块级作用域内声明函数</h4>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。且块级作用域必须有大括号。<h4 id="2-4-do表达式"><a href="#2-4-do表达式" class="headerlink" title="2.4 do表达式"></a>2.4 do表达式</h4>在块级作用域前加上<code>do</code>关键字，可以<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="keyword">do</span> &#123;</div><div class="line">  <span class="keyword">let</span> t = f();</div><div class="line">  t * t + <span class="number">1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-const命令"><a href="#3-const命令" class="headerlink" title="3. const命令"></a>3. const命令</h3><h4 id="3-1-基本用法"><a href="#3-1-基本用法" class="headerlink" title="3.1 基本用法"></a>3.1 基本用法</h4><p>与<code>let</code>相同，除了<code>const</code>用于声明常量，声明时必须初始化，不能只声明不赋值。</p>
<h4 id="3-2-本质"><a href="#3-2-本质" class="headerlink" title="3.2 本质"></a>3.2 本质</h4><p><code>const</code>实际上是保证变量指向的那个内存地址不能改动。如果声明的变量是个对象或数组，可以对该对象进行添加属性等操作，但不能将它指向另一个新的对象。<br>如果想让对象的属性也不能改变，可以将对象彻底冻结：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">Object</span>.freeze(obj);</div><div class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span>( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> )&#123;</div><div class="line">      <span class="built_in">Object</span>.freeze(obj[key]);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="3-3-ES6声明变量有六种方法："><a href="#3-3-ES6声明变量有六种方法：" class="headerlink" title="3.3 ES6声明变量有六种方法："></a>3.3 ES6声明变量有六种方法：</h4><p><code>var, function, let, const, import, class</code><br>前两个命令声明的全局变量，依旧是顶层对象(<code>window, global</code>)的属性；<code>let, const, class</code>声明的变量不属于顶层对象的属性。</p>
<h3 id="5-global对象"><a href="#5-global对象" class="headerlink" title="5. global对象"></a>5. global对象</h3><p>为了在浏览器，Node，Web Worker中都能获取顶层对象，引入垫片库<code>system.global</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CommonJS的写法</span></div><div class="line"><span class="keyword">var</span> global = <span class="built_in">require</span>(<span class="string">'system.global'</span>)();</div><div class="line"></div><div class="line"><span class="comment">// ES6模块的写法</span></div><div class="line"><span class="keyword">import</span> getGlobal <span class="keyword">from</span> <span class="string">'system.global'</span>;</div><div class="line"><span class="keyword">const</span> global = getGlobal();</div></pre></td></tr></table></figure></p>
<p>虽然我目前还不知道为什么需要获取全局对象。。</p>
<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p>destructuring 模式匹配-解构失败则赋值为<code>undefined</code></p>
<h3 id="1-数组解构赋值"><a href="#1-数组解构赋值" class="headerlink" title="1. 数组解构赋值"></a>1. 数组解构赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">head <span class="comment">// 1</span></div><div class="line">tail <span class="comment">// [2, 3, 4]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</div><div class="line">x <span class="comment">// "a"</span></div><div class="line">y <span class="comment">// undefined</span></div><div class="line">z <span class="comment">// []</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]); <span class="comment">//Set结构也可以解构成功</span></div><div class="line"></div><div class="line"><span class="comment">//只要是具备Iterator接口的数据结构，比如Generator函数，就可以用数组形式解构赋值</span></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</div><div class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">yield</span> a;</div><div class="line">    [a, b] = [b, a + b];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</div><div class="line">sixth <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>解构赋值可以指定默认值，只有在相应位置的值===undefined时，才会使用默认值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [];</div><div class="line">x <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</div><div class="line">x <span class="comment">// null</span></div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line">如果默认值是表达式，则该表达式为惰性求值，只有在用到的时候才会求值。</div><div class="line">默认值可以引用解构赋值的其他变量，但该变量必须已声明。</div><div class="line"></div><div class="line">### 2. 对象解构赋值</div><div class="line">- 对象与数组的解构赋值的不同在于：数组有序，根据位置顺序赋值；对象无序，根据同名属性赋值。</div><div class="line">- 关于模式和变量：</div><div class="line">`<span class="string">``</span>javascript</div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">baz <span class="comment">// "aaa"</span></div><div class="line">foo <span class="comment">// error: foo is not defined</span></div><div class="line"><span class="comment">//foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</span></div><div class="line"><span class="comment">//且这种写法(let + :)相当于声明+赋值，所以赋值的变量不能是以前声明过的。</span></div></pre></td></tr></table></figure></p>
<ul>
<li>如果赋值语句以大括号开头，必须用圆括号包裹起来，否则大括号放在行首会被解析器当做代码块而不是赋值语句。</li>
<li>对象也可以嵌套解构赋值，但要注意模式不会被赋值，变量才会。</li>
<li>数组是特殊的对象，也可以使用对象解构的方法解构赋值。</li>
</ul>
<h3 id="3-字符串解构赋值"><a href="#3-字符串解构赋值" class="headerlink" title="3. 字符串解构赋值"></a>3. 字符串解构赋值</h3><p>字符串会被转换成类数组对象，有<code>length</code>属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</div><div class="line">a <span class="comment">// "h"</span></div><div class="line">b <span class="comment">// "e"</span></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</div><div class="line">len <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<h3 id="4-数值和布尔值的解构赋值"><a href="#4-数值和布尔值的解构赋值" class="headerlink" title="4. 数值和布尔值的解构赋值"></a>4. 数值和布尔值的解构赋值</h3><p>解构赋值的右边如果不是对象或数组都会先转为对象。<code>undefined</code>和<code>null</code>无法转成对象，解构赋值写在右边会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</div><div class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</div><div class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h3 id="5-函数参数的解构赋值"><a href="#5-函数参数的解构赋值" class="headerlink" title="5. 函数参数的解构赋值"></a>5. 函数参数的解构赋值</h3><p>注意以下两种情况的区别：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为变量x和y指定默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></div><div class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></div><div class="line">move(); <span class="comment">// [0, 0]</span></div><div class="line"></div><div class="line"><span class="comment">//为函数参数指定默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></div><div class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></div><div class="line">move(); <span class="comment">// [0, 0] ?why</span></div></pre></td></tr></table></figure></p>
<h3 id="6-圆括号问题"><a href="#6-圆括号问题" class="headerlink" title="6. 圆括号问题"></a>6. 圆括号问题</h3><p>能不用就不用。能用的情况：赋值语句的非模式部分</p>
<h3 id="7-解构赋值的用途"><a href="#7-解构赋值的用途" class="headerlink" title="7. 解构赋值的用途"></a>7. 解构赋值的用途</h3><ul>
<li>交换变量的值</li>
<li>从函数中返回多个值</li>
<li>函数传参对应</li>
<li>提取json数据</li>
<li>函数参数的默认值</li>
<li><p>遍历Map结构：<code>for...of</code>遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取键名</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 获取键值</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 获取键值对</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>输入模块的指定方法<br><code>const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);</code></p>
</li>
</ul>
<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><h3 id="1-字符串的Unicode表示法"><a href="#1-字符串的Unicode表示法" class="headerlink" title="1. 字符串的Unicode表示法"></a>1. 字符串的Unicode表示法</h3><p><code>\u{xxxx}</code>即使xxxx超过范围（<code>\u0000~\uFFFF</code>），也可以正确解读。以前要用两个双字节（32bit）的形式表示超出范围的字符，否则会解读成两个字符。</p>
<h3 id="2-codePointAt-index-对应于charAt-index"><a href="#2-codePointAt-index-对应于charAt-index" class="headerlink" title="2. codePointAt(index) 对应于charAt(index)"></a>2. codePointAt(index) 对应于charAt(index)</h3><ul>
<li>该方法定义在字符串的实例对象上</li>
<li>将字符转成码点</li>
<li>js内部字符以UTF-16格式储存，每个字符固定为2字节（双字节，16bit）。对于需要两个双字节储存的字符来说，js会认为它们是两个字符：<code>length</code>为误判为2；用<code>charAt</code>和<code>charCodeAt</code>都无法读取整个字符，而是会分别返回前两个字节和后两个字节。</li>
<li>ES6解决办法：<code>codePointAt()</code>会正确返回32bit的字符的码点，默认以十进制值表示，如果要十六进制的值，可以用<code>toString</code>转换。</li>
<li><p>遍历含有32bit字符的字符串时，为避免字符串索引下标问题（如果用下标访问字符，还是要把32bit字符当做占了2个下标来看待），应该用<code>for...of</code>循环，它会正确识别32bit的UTF-16字符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'𠮷a'</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</div><div class="line">  <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>));</div><div class="line">&#125;</div><div class="line"><span class="comment">// 20bb7</span></div><div class="line"><span class="comment">// 61</span></div></pre></td></tr></table></figure>
</li>
<li><p>利用<code>codePointAt()</code>测试一个字符是16bit还是32bit</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-String-fromCodePoint-codePoint-对应于fromCharCode-codePoint"><a href="#2-String-fromCodePoint-codePoint-对应于fromCharCode-codePoint" class="headerlink" title="2. String.fromCodePoint(codePoint) 对应于fromCharCode(codePoint)"></a>2. String.fromCodePoint(codePoint) 对应于fromCharCode(codePoint)</h3><ul>
<li>该方法定义在String上</li>
<li>将码点转化为字符串，可传入多个码点</li>
<li>可以识别大于<code>0xFFFF</code>的字符</li>
</ul>
<h3 id="3-at-index-对应于charAt-index"><a href="#3-at-index-对应于charAt-index" class="headerlink" title="3. at(index) 对应于charAt(index)"></a>3. at(index) 对应于charAt(index)</h3><ul>
<li>获取给定位置的字符</li>
<li>可以识别大于<code>0xFFFF</code>的字符</li>
</ul>
<h3 id="4-normalize"><a href="#4-normalize" class="headerlink" title="4. normalize()"></a>4. normalize()</h3><p>Unicode正规化</p>
<h3 id="5-includes-startsWith-endsWith"><a href="#5-includes-startsWith-endsWith" class="headerlink" title="5. includes(), startsWith(), endsWith()"></a>5. includes(), startsWith(), endsWith()</h3><ul>
<li>第一个参数为源字符串，第二个参数可选，表示开始搜索的位置</li>
<li>均返回布尔值，表示是否找到/是否在源字符串的开头/末尾</li>
</ul>
<h3 id="6-repeat"><a href="#6-repeat" class="headerlink" title="6. repeat()"></a>6. repeat()</h3><p>返回一个新字符串，表示将原字符串重复n次。参数如果是小数，会被取整；如果是字符串，则会先转换成数字。</p>
<h3 id="7-padStart-padEnd"><a href="#7-padStart-padEnd" class="headerlink" title="7. padStart(), padEnd()"></a>7. padStart(), padEnd()</h3><ul>
<li>字符串长度补全，头部/尾部补全。</li>
<li>原字符串长度大于第一个参数：返回原字符串。</li>
<li>原字符串与补全串长度之和大于第一个参数，截去超出位数的补全字符串。</li>
<li>第二个参数省略则默认为空格</li>
<li><code>padStart()</code>常见用途：为数值补全指定位数；提示字符串格式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'123456'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000123456"</span></div><div class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-MM-12"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="8-模板字符串"><a href="#8-模板字符串" class="headerlink" title="8. 模板字符串"></a>8. 模板字符串</h3><ul>
<li>用反引号标识，可以包含html标签</li>
<li>可以用<code>${}</code>嵌入变量，表达式运算，访问对象属性，函数调用。</li>
<li>如果大括号内不是字符串，比如对象，会调用其<code>toString()</code></li>
<li>如果大括号内变量未定义，会报错。</li>
<li>模板字符串可嵌套</li>
<li><p>引用模板字符串本身</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一：用new Function('param', str)</span></div><div class="line"><span class="keyword">let</span> str = <span class="string">'return '</span> + <span class="string">'`Hello $&#123;name&#125;!`'</span>;</div><div class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'name'</span>, str);</div><div class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></div><div class="line"></div><div class="line"><span class="comment">// 写法二：用eval.call(null, str)</span></div><div class="line"><span class="keyword">let</span> str = <span class="string">'(name) =&gt; `Hello $&#123;name&#125;!`'</span>;</div><div class="line"><span class="keyword">let</span> func = <span class="built_in">eval</span>.call(<span class="literal">null</span>, str);</div><div class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>模板编译实例</strong>：正则表达式匹配-将template string转换成含<code>echo</code>的js表达式字符串；将转换后的template string放到一个用模板字符串写的函数里，作为编译函数<code>compile(template)</code>的返回值<code>script</code>；调用该编译函数。</p>
</li>
<li>标签模板：函数调用的特殊形式。标签-函数，模板-参数。<br>若模板字符串里有多个参数，则相当于传参：第一个参数为数组，元素是没有变量替换的部分，后面的参数依次为变量替换后的值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如何将各个参数按照原来的位置合并回去</span></div><div class="line"><span class="keyword">var</span> total = <span class="number">30</span>;</div><div class="line"><span class="keyword">var</span> msg = passthru <span class="string">`The total is <span class="subst">$&#123;total&#125;</span> (<span class="subst">$&#123;total*<span class="number">1.05</span>&#125;</span> with tax)`</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// console.log("~~~~literals: ~~~~", literals);</span></div><div class="line">    <span class="comment">// console.log("~~~~arguments:~~~~", arguments);</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> result = <span class="string">''</span>;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (i &lt; literals.length) &#123; <span class="comment">//3</span></div><div class="line"></div><div class="line">        <span class="comment">// console.log("----literals[", i, "]----", literals[i]);</span></div><div class="line"></div><div class="line">        result += literals[i++];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (i &lt; <span class="built_in">arguments</span>.length) &#123; <span class="comment">//3</span></div><div class="line"></div><div class="line">            <span class="comment">// console.log("====arguments[", i, "]====", arguments[i]);</span></div><div class="line"></div><div class="line">            result += <span class="built_in">arguments</span>[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(msg); <span class="comment">// "The total is 30 (31.5 with tax)"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//采用rest参数的写法：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals, ...values</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> output = <span class="string">""</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</div><div class="line">    output += literals[index] + values[index];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  output += literals[index]</div><div class="line">  <span class="keyword">return</span> output;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>-（敲黑板！）标签模板的重要应用：过滤HTML字符串，将特殊字符如<code>&lt;``&gt;</code>转义，防止用户输入恶意内容，注入不安全代码。</p>
<ul>
<li>React的jsx语法其实就用了模板字符串，定义jsx函数，将DOM字符串转成React对象。</li>
<li>模板处理函数的第一个参数是模板字符串，其实是模板字符串数组，该数组的第一个元素是字符串本身，第二个元素是raw属性，保存转义后的原字符串。</li>
<li><code>String.raw()</code></li>
</ul>
<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><h3 id="1-Array-from"><a href="#1-Array-from" class="headerlink" title="1. Array.from()"></a>1. <code>Array.from()</code></h3><ul>
<li>将类数组对象（如arguments, DOM操作返回的NodeList）转成真正的数组；<br>ES5: <code>[].slice.call(arraylike);</code><br>ES6: <code>Array.from(arraylike);</code><br>扩展运算符<code>...</code>也可以实现此功能：本质上还是调用Iterator接口。<br><code>var arr = [...arguments];</code><br><code>var arr = [...document.querySelectorAll(&#39;div&#39;)];</code></li>
<li>将可遍历对象（部署了Iterator接口的数据结构，如ES6新增数据结构Set和Map）转成真正的数组。</li>
<li>可接收第二个参数：接收一个函数，类似于数组的<code>map</code>方法。</li>
<li>如果<code>map</code>函数用到了<code>this</code>，还可以传入第三个参数用来绑定<code>this</code></li>
<li>看一个灵活的用法：用第一个参数指定第二个参数的运行次数<br><code>Array.from({ length: 2 }, () =&gt; &#39;jack&#39;); // [&#39;jack&#39;, &#39;jack&#39;]</code></li>
</ul>
<h3 id="2-Array-of"><a href="#2-Array-of" class="headerlink" title="2.Array.of()"></a>2.<code>Array.of()</code></h3><ul>
<li>这个函数的出现是为了弥补构造函数  <code>Array()</code>的不足：它的行为很统一，总是返回一个由参数作为元素的数组。而构造函数只有在参数不少于2个时才返回数组，参数只有一个时只会指定新数组的长度。</li>
<li>模拟：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>下面介绍的都是数组实例方法，即：用数组实例arr调用，或<code>Array.prototype.</code>调用</p>
<h3 id="3-数组实例方法copyWithin"><a href="#3-数组实例方法copyWithin" class="headerlink" title="3. 数组实例方法copyWithin()"></a>3. 数组实例方法<code>copyWithin()</code></h3><p><code>copyWithin(target, start = 0, end = this.length);</code></p>
<ul>
<li>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。数组会被修改。</li>
<li>如果负数，倒数，-1对应最后一个元素。</li>
<li>这里的例子出现了<code>new Int32Array()</code>，js对象的32 位整数值的类型化数组。</li>
</ul>
<h3 id="4-数组实例方法find-和findIndex"><a href="#4-数组实例方法find-和findIndex" class="headerlink" title="4. 数组实例方法find()和findIndex()"></a>4. 数组实例方法<code>find()</code>和<code>findIndex()</code></h3><ul>
<li>参数均为回调函数，<code>find()</code>找出第一个符合参数函数条件的数组成员，没有则返回<code>undefined</code>；<code>findIndex()</code>找出相应的位置，没有则返回-1。</li>
<li>回调函数的参数：当前遍历的value, 当前遍历位置index, 原数组arr。</li>
<li>均可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</li>
<li>均可以发现<code>NaN</code>，弥补了<code>indexOf()</code>的不足<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>); <span class="comment">// -1</span></div><div class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y)); <span class="comment">// 0</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-数组实例方法fill"><a href="#5-数组实例方法fill" class="headerlink" title="5. 数组实例方法fill()"></a>5. 数组实例方法<code>fill()</code></h3><ul>
<li>适用于填充空数组。非空数组原有元素会被替代。</li>
<li><code>fill(value, start, end)</code>，可指定始末位置。</li>
</ul>
<h3 id="6-数组实例方法entries-keys-values"><a href="#6-数组实例方法entries-keys-values" class="headerlink" title="6. 数组实例方法entries(), keys(), values()"></a>6. 数组实例方法<code>entries(), keys(), values()</code></h3><ul>
<li>用于遍历数组：键值对、键、值。</li>
<li>配合<code>for...of</code>或<code>arr.entries().next()</code>遍历<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(index, elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0 "a"</span></div><div class="line"><span class="comment">// 1 "b"</span></div><div class="line"><span class="keyword">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"><span class="keyword">let</span> entries = letter.entries();</div><div class="line"><span class="built_in">console</span>.log(entries.next()); <span class="comment">//&#123; value: [ 0, 'a' ], done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(entries.next()); <span class="comment">//&#123; value: [ 1, 'b' ], done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(entries.next()); <span class="comment">//&#123; value: [ 2, 'c' ], done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(entries.next()); <span class="comment">//&#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="7-数组实例方法includes"><a href="#7-数组实例方法includes" class="headerlink" title="7. 数组实例方法includes()"></a>7. 数组实例方法<code>includes()</code></h3><ul>
<li>是对ES5数组方法<code>indexOf()</code>的弥补。</li>
<li>检测数组中是否包含目标元素，可以检测出<code>NaN</code></li>
<li>第二个参数可选，搜索的起始位置。</li>
<li>Map和Set数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</li>
</ul>
<p>Map结构的has方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。<br>Set结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</p>
<h3 id="8-数组的空位"><a href="#8-数组的空位" class="headerlink" title="8. 数组的空位"></a>8. 数组的空位</h3><ul>
<li>ES5对空位的处理很不统一， ES6明确将空位转化成<code>undefined</code></li>
<li><code>Array.from()</code></li>
<li>扩展运算符<code>...</code></li>
<li><code>copyWithin(), fill(), for...of, entries(), keys(), values(), find(), findIndex()</code></li>
<li>尽量避免出现空位</li>
</ul>
<h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><h3 id="1-函数的默认值"><a href="#1-函数的默认值" class="headerlink" title="1. 函数的默认值"></a>1. 函数的默认值</h3><ul>
<li>允许为参数赋默认值，可以是具体值，也可以是表达式-惰性求值</li>
<li>不能在函数体内对参数变量再次声明</li>
<li><p>与解构赋值结合使用。看这两种写法的区别：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一:函数参数的默认值是空对象，但是设置了对象解构赋值的默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 写法二:函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数没有参数的情况</span></div><div class="line">m1() <span class="comment">// [0, 0]</span></div><div class="line">m2() <span class="comment">// [0, 0]</span></div><div class="line"></div><div class="line"><span class="comment">// x和y都有值的情况</span></div><div class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></div><div class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></div><div class="line"></div><div class="line"><span class="comment">// x有值，y无值的情况</span></div><div class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></div><div class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></div><div class="line"></div><div class="line"><span class="comment">// x和y都无值的情况</span></div><div class="line">m1(&#123;&#125;) <span class="comment">// [0, 0];</span></div><div class="line">m2(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></div></pre></td></tr></table></figure>
</li>
<li><p>定义了 默认值的参数尽量作为尾参数</p>
</li>
<li>指定了默认值后函数的<code>length</code>属性将返回没有指定默认值的参数个数<ul>
<li><code>length</code>属性是预期传入的参数个数</li>
<li>rest参数也不会计入<code>length</code>属性</li>
<li>！！！如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了</li>
</ul>
</li>
<li>作用域<br>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</li>
<li>应用：利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing(</span>)) </span>&#123;</div><div class="line">  <span class="keyword">return</span> mustBeProvided;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()</div><div class="line"><span class="comment">// Error: Missing parameter</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-rest参数"><a href="#2-rest参数" class="headerlink" title="2. rest参数"></a>2. rest参数</h3><ul>
<li>代替<code>arguments</code>对象，获取函数的多余参数。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</li>
<li>rest参数之后不能再有其他参数。</li>
<li>函数的<code>length</code>属性不包括rest参数</li>
</ul>
<h3 id="3-扩展运算符"><a href="#3-扩展运算符" class="headerlink" title="3. 扩展运算符"></a>3. 扩展运算符</h3><ul>
<li><p>主要用于函数传参，把数组或类数组对象展开成一系列用逗号隔开的参数序列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    <span class="built_in">console</span>.log(b);</div><div class="line">    <span class="built_in">console</span>.log(c);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="comment">//传统写法</span></div><div class="line">foo(arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>]);</div><div class="line"></div><div class="line"><span class="comment">//使用扩展运算符</span></div><div class="line">foo(...arr);</div><div class="line"><span class="comment">//1</span></div><div class="line"><span class="comment">//2</span></div><div class="line"><span class="comment">//3</span></div></pre></td></tr></table></figure>
</li>
<li><p>替代数组的<code>apply</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"><span class="comment">// ES5的写法</span></div><div class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</div><div class="line"><span class="comment">// ES6的写法</span></div><div class="line">arr1.push(...arr2);</div><div class="line"><span class="comment">//ES5写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。</span></div><div class="line"></div><div class="line"><span class="comment">// ES5的写法</span></div><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr1);</div><div class="line"><span class="comment">// ES6的写法</span></div><div class="line"><span class="built_in">Math</span>.max(...arr1);</div></pre></td></tr></table></figure>
</li>
<li><p>应用：</p>
<ul>
<li>合并数组，替代<code>concat</code>方法。</li>
<li>与解构赋值结合，生成新数组，扩展运算符要放在最后一位。</li>
<li>函数返回值为多个，要作为另一个函数的参数时，可用扩展运算符处理返回值然后作为传参。</li>
<li><p>将字符串转为数组：能正确识别32位Unicode字符。包括长度、<code>reverse</code>反转字符串时的32位Unicode字符问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str = <span class="string">'x\uD83D\uDE80y'</span>;</div><div class="line"></div><div class="line">str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</div><div class="line"><span class="comment">// 'y\uDE80\uD83Dx' 这个结果不是我们想要的，中间应该是一个字符整体。</span></div><div class="line"></div><div class="line">[...str].reverse().join(<span class="string">''</span>)</div><div class="line"><span class="comment">// 'y\uD83D\uDE80x'</span></div></pre></td></tr></table></figure>
</li>
<li><p>任何部署了Iterator接口的对象(Map, Set, Generator函数)，都可以用扩展运算符转为真正的数组。如果要将没有部署Iterator接口的类数组对象转为真正的数组：用<code>Array.from()</code>方法。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-严格模式"><a href="#4-严格模式" class="headerlink" title="4. 严格模式"></a>4. 严格模式</h3><p>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式。<br>是为了规避ES5中函数参数部分先于函数体部分执行可能带来的问题：ES5中，若函数体中有规定严格模式而参数执行不符合严格模式，则会先执行参数部分然后才报错。</p>
<h3 id="5-name属性"><a href="#5-name属性" class="headerlink" title="5. name属性"></a>5. name属性</h3><p>作为函数的属性，体现函数的名称。若将一个匿名函数赋给一个变量，则ES6中name为该变量名，ES5中name为空字符串。</p>
<h3 id="6-箭头函数"><a href="#6-箭头函数" class="headerlink" title="6. 箭头函数"></a>6. 箭头函数</h3><ul>
<li>ES6中大括号开头会被解释为代码块，所以如果直接返回一个对象，要在对象外面加上小括号。</li>
<li>函数体内的<code>this</code>对象，指向定义时所在对象，而不是运行时所在对象。<br>箭头函数没有自己的<code>this</code>，它引用外层代码块的<code>this</code>。也不能用<code>bind</code>, <code>call</code>, <code>apply</code>改变<code>this</code>的指向。除了<code>this</code>，<code>arguments</code>, <code>super</code>, <code>new.target</code>这三个变量在箭头函数中也不存在，指向外层函数的相应变量。</li>
<li>不能当作构造函数，不能使用<code>new</code>，因为箭头函数没有自己的<code>this</code></li>
<li>不能使用<code>arguments</code>对象，可以用rest参数代替。</li>
<li>不能使用<code>yield</code>命令，所以不能当作Generator函数。</li>
<li>嵌套的箭头函数<br>部署管道机制：前一个函数的输出是后一个函数的输入<br>改写lamda演算。</li>
</ul>
<h3 id="7-绑定this"><a href="#7-绑定this" class="headerlink" title="7. 绑定this"></a>7. 绑定this</h3><p>双冒号，ES7提案，Babel已支持。左边是对象，右边是函数，将对象绑定在函数上面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo::bar;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">bar.bind(foo);</div><div class="line"></div><div class="line">foo::bar(...arguments);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">bar.apply(foo, <span class="built_in">arguments</span>);</div></pre></td></tr></table></figure></p>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。<br>双冒号返回的是原对象，可以采用链式写法。</p>
<h3 id="8-尾调用优化-（-好难…）"><a href="#8-尾调用优化-（-好难…）" class="headerlink" title="8. 尾调用优化 （*好难…）"></a>8. 尾调用优化 （*好难…）</h3><ul>
<li>什么是尾调用：函数的最后一步是执行另一个函数，不能有附加的调用后的其他操作。<br>-如何优化：只保留内层函数的调用帧。因为函数嵌套调用会形成调用帧，调用栈，会在内存中保存外层函数的信息及内层函数的位置信息等，如果是尾调用，并且不再需要外层函数的内部变量，则只需要保存内层函数就行了，可以删除外层函数的调用帧。（改写了函数的调用栈）</li>
<li>尾递归：不会发生栈溢出，节省内存。</li>
<li>递归函数的改写：确保最后一步只调用自身：把所有用到的内部变量改写成函数的参数。<ul>
<li>在尾递归函数之外，再提供一个正常行驶的函数。</li>
<li>curry化</li>
<li>使用ES6的函数参数默认值</li>
</ul>
</li>
<li>递归本质是循环。函数式编程语言没有循环操作的命令，都是用递归实现循环操作，尾递归对这些语言很重要。</li>
<li>ES6 一旦使用递归，最好使用尾递归。</li>
<li>尾调用模式只在严格模式下生效。</li>
<li>自己实现尾递归优化：将递归换成循环。</li>
<li>蹦床函数 + 将递归函数改写成每一步返回另一个函数</li>
</ul>
<h3 id="9-尾逗号"><a href="#9-尾逗号" class="headerlink" title="9. 尾逗号"></a>9. 尾逗号</h3><p>ES2017允许函数的最后一个参数有逗号，方便添加、修改参数。</p>
<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><h3 id="1-属性的简洁表示法"><a href="#1-属性的简洁表示法" class="headerlink" title="1. 属性的简洁表示法"></a>1. 属性的简洁表示法</h3><ul>
<li>在对象中直接写变量：属性名就是变量名，属性值就是变量的值；</li>
<li>方法也可以简写</li>
<li>这种写法用于函数的返回值为对象时很方便</li>
<li>CommonJS输出变量，属性的赋值器和取值器 都适用这种写法</li>
<li>属性名总是会解析成字符串</li>
</ul>
<h3 id="2-属性名表达式"><a href="#2-属性名表达式" class="headerlink" title="2. 属性名表达式"></a>2. 属性名表达式</h3><ul>
<li>用字面量定义对象时，可以用<code>[表达式]</code>作为属性名、方法名</li>
<li>属性名表达式和简洁表示法不能同时使用，一般用属性名表达式作为属性名之后，要写上属性值</li>
<li>属性名表达式如果是个对象，会自动将对象转为字符串作为属性名，所以如果有多个对象作为属性名，最后只会有最后那个对象转字符串作为属性名，发生覆盖。</li>
</ul>
<h3 id="3-方法的name属性"><a href="#3-方法的name属性" class="headerlink" title="3. 方法的name属性"></a>3. 方法的name属性</h3><ul>
<li>返回方法名</li>
<li><p>如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  get foo() &#123;&#125;,</div><div class="line">  set foo(x) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.foo.name</div><div class="line"><span class="comment">// TypeError: Cannot read property 'name' of undefined</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>);</div><div class="line"></div><div class="line">descriptor.get.name <span class="comment">// "get foo"</span></div><div class="line">descriptor.set.name <span class="comment">// "set foo"</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>bind</code>方法创造的函数，name属性返回bound加上原函数的名字；<code>Function</code>构造函数创造的函数，name属性返回anonymous。</p>
</li>
<li>如果对象的方法名是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。</li>
</ul>
<h3 id="4-Object-is"><a href="#4-Object-is" class="headerlink" title="4. Object.is()"></a>4. Object.is()</h3><ul>
<li><p>与ES5严格相等<code>===</code>行为基本一致，但弥补了<code>+0</code>应该不等于<code>-0</code>和<code>NaN</code>应该等于自身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></div><div class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
</li>
<li><p>如何在ES5中手动部署这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>, <span class="string">'is'</span>, &#123;</div><div class="line">  <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x === y) &#123;</div><div class="line">      <span class="comment">// 针对+0 不等于 -0的情况</span></div><div class="line">      <span class="keyword">return</span> x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 针对NaN的情况</span></div><div class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">writable</span>: <span class="literal">true</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-Object-assign-target-source1-source2"><a href="#5-Object-assign-target-source1-source2" class="headerlink" title="5. Object.assign(target, source1, source2)"></a>5. Object.assign(target, source1, source2)</h3><ul>
<li>对象的合并：将源对象（可多个）的所有可枚举属性赋值到目标对象（1个）</li>
<li><p>不在首参数的字符串会以字符数组的形式拷贝进目标对象。其他类型值如数值、布尔值，都没有任何效果，因为只有字符串的包装对象会产生可枚举属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>(<span class="literal">true</span>) <span class="comment">// &#123;[[PrimitiveValue]]: true&#125;</span></div><div class="line"><span class="built_in">Object</span>(<span class="number">10</span>)  <span class="comment">//  &#123;[[PrimitiveValue]]: 10&#125;</span></div><div class="line"><span class="built_in">Object</span>(<span class="string">'abc'</span>) <span class="comment">// &#123;0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"&#125;</span></div><div class="line"><span class="comment">//PrimitiveValue是包装对象的内部属性，这个值不会被Object.assign拷贝</span></div></pre></td></tr></table></figure>
</li>
<li><p>不拷贝继承属性和不可枚举的属性</p>
</li>
<li>是浅拷贝</li>
<li>同名属性会被替换</li>
<li><p>会把数组视为对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</div><div class="line"><span class="comment">// [4, 5, 3]</span></div></pre></td></tr></table></figure>
</li>
<li><p>用处：</p>
<ul>
<li>为对象添加属性、方法</li>
<li><p>克隆对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123; <span class="comment">//只能克隆origin自身的值，不能克隆其继承值</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123; <span class="comment">//保持了继承链，连同其继承的值一并克隆</span></div><div class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>合并多个对象</p>
</li>
<li>为属性指定默认值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> DEFAULTS = &#123; <span class="comment">//其中的属性最好不要是对象，因为是浅拷贝，可能会被options对象全部覆盖，达不到预期的只改变某几个参数的效果</span></div><div class="line">  logLevel: <span class="number">0</span>,</div><div class="line">  <span class="attr">outputFormat</span>: <span class="string">'html'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processContent</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">  options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options); <span class="comment">//options是用户提供的参数，会覆盖DEFAULTS中的同名参数。</span></div><div class="line">  <span class="built_in">console</span>.log(options);</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="6-属性的可枚举性"><a href="#6-属性的可枚举性" class="headerlink" title="6. 属性的可枚举性"></a>6. 属性的可枚举性</h3><ul>
<li><p><code>Object.getOwnPropertyDescriptor</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>)</div><div class="line"><span class="comment">//  &#123;</span></div><div class="line"><span class="comment">//    value: 123,</span></div><div class="line"><span class="comment">//    writable: true,</span></div><div class="line"><span class="comment">//    enumerable: true,</span></div><div class="line"><span class="comment">//    configurable: true</span></div><div class="line"><span class="comment">//  &#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p>ES5中只处理可枚举属性的方法：<br><code>for...in</code> 继承的和自身的。<code>toString</code>和<code>length</code>属性都是不可枚举的所以可以不被遍历到。尽量不用这个来遍历而用下面的。<br><code>Object.keys()</code> 自身的<br><code>JSON.stringify()</code> 自身的</p>
</li>
</ul>
<h3 id="7-属性的遍历"><a href="#7-属性的遍历" class="headerlink" title="7. 属性的遍历"></a>7. 属性的遍历</h3><p>  for…in 自身+继承，可枚举的，无Symbol属性<br>  Object.keys(obj) 同上，除了继承<br>  Object.getOwnPropertyNames(obj) 自身，可枚举+不可枚举，无Symbol属性<br>  Object.getOwnPropertySymbols(obj) 自身的Symbol属性<br>  Reflect.ownKeys(obj) 自身，可枚举+不可枚举，含Symbol</p>
<h3 id="8-设置-读取原型对象"><a href="#8-设置-读取原型对象" class="headerlink" title="8. 设置/读取原型对象"></a>8. 设置/读取原型对象</h3><ul>
<li><code>Object.setPrototypeOf(obj, proto);</code></li>
<li><code>Object.getPrototypeOf()</code></li>
</ul>
<h3 id="9-Object-keys-遍历补充"><a href="#9-Object-keys-遍历补充" class="headerlink" title="9.Object.keys()遍历补充"></a>9.Object.keys()遍历补充</h3><p>都是遍历自身的，可枚举的，无Symbol属性<br><code>Object.keys()</code><br><code>Object.values()</code><br><code>Object.entries()</code></p>
<h3 id="10-对象的扩展运算符"><a href="#10-对象的扩展运算符" class="headerlink" title="10. 对象的扩展运算符"></a>10. 对象的扩展运算符</h3><ul>
<li>解构赋值：<ul>
<li>等号右边得是对象</li>
<li>是浅拷贝</li>
<li>只会拷贝对象自身的属性，不会拷贝继承的属性</li>
<li>扩展运算符用于解构赋值要作为最后一个参数，否则报错。</li>
</ul>
</li>
<li>扩展运算符</li>
</ul>
<h3 id="11-Object-getOwnPropertyDescriptor"><a href="#11-Object-getOwnPropertyDescriptor" class="headerlink" title="11. Object.getOwnPropertyDescriptor"></a>11. <code>Object.getOwnPropertyDescriptor</code></h3><ul>
<li>配合<code>Object.create()</code> 实现浅拷贝<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> clone = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj),</div><div class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="12-Null传导运算符"><a href="#12-Null传导运算符" class="headerlink" title="12. Null传导运算符"></a>12. Null传导运算符</h3><ul>
<li>简化赋值运算前的层层判断<br><code>const firstName = message?.body?.user?.firstName || &#39;default&#39;;</code></li>
<li>传导运算符的四种用法：<ul>
<li><code>Obj?.prop</code> 读取对象属性</li>
<li><code>Obj?.[expr]</code> 同上</li>
<li><code>func?.(...args)</code> 函数的调用</li>
<li><code>new C?.[...args]</code> 构造函数的调用</li>
</ul>
</li>
</ul>
<h2 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h2><h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h3><ul>
<li>两个<code>NaN</code>是相等，两个对象不相等</li>
<li><code>new Set()</code>接收参数可以为：数组或类数组对象</li>
<li>Set实例的方法：<ul>
<li><code>Set.prototype.constructor</code>, </li>
<li><code>Set.prototype.size</code>, </li>
<li><code>add(value)返回Set本身，所以可以链式调用这个方法</code>, </li>
<li><code>delete(value)</code></li>
<li><code>has(value)</code></li>
<li><code>clear()</code></li>
</ul>
</li>
<li><code>Array.from(set)</code>将set转为数组</li>
<li>数组去重： <code>[...new Set(array)]</code>或<code>Array.from(new Set(array))</code></li>
<li><p>遍历操作：<code>keys()</code>,<code>values()</code>,<code>entries()</code>，可以直接用<code>for...of</code>遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> set)&#123;&#125;</div><div class="line">set.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;&#125;) <span class="comment">//注意是先写value后写key</span></div></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符，<code>map</code>, <code>filter</code>方法都可以用于Set</p>
</li>
<li><p>集合的交集、并集、差集的实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]); <span class="comment">//并集</span></div><div class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x))); <span class="comment">//交集</span></div><div class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x))); <span class="comment">//差集</span></div></pre></td></tr></table></figure>
</li>
<li><p>遍历的同时向改变Set元素的值：<code>map</code>或<code>Array.from</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法一</span></div><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>));</div><div class="line"><span class="comment">// 方法二</span></div><div class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">Array</span>.from(set, val =&gt; val * <span class="number">2</span>));</div><div class="line"><span class="comment">// set的值是2, 4, 6</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2. WeakSet"></a>2. WeakSet</h3><p>（1）与Set的两点不同：</p>
<ul>
<li>成员只能是对象</li>
<li>成员对象都是弱引用。如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象是否还存在于 WeakSet 之中。<br>WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在忘记取消引用而导致内存无法释放、内存泄漏的问题。因此，WeakSet 适合临时存放一组对象（比如储存 DOM 节点，不用担心这些节点从文档移除时，会引发内存泄漏），以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakMap 里面的引用就会自动消失。<br>WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</li>
</ul>
<p>（2）构造函数的对象为数组或类数组对象，且其中元素必须为对象。</p>
<h3 id="3-Map"><a href="#3-Map" class="headerlink" title="3. Map"></a>3. Map</h3><ul>
<li>是对Object Hash结构的弥补：Object结构：“键-值”对应，Map结构：“值-值”对应</li>
<li>构造函数接收数组（元素为键值对形式的数组）作为参数</li>
<li>同一个键多次赋值，会覆盖</li>
<li>同一个键的定义：要为同一个对象（内存地址相同）</li>
<li>实例方法、遍历方法类似于Set结构：<ul>
<li><code>set(key, value)</code>可链式调用</li>
</ul>
</li>
<li><strong>Map与数组、对象、JSON的互相转换</strong></li>
</ul>
<h3 id="4-WeakMap"><a href="#4-WeakMap" class="headerlink" title="4. WeakMap"></a>4. WeakMap</h3><p>（1） 只接受对象作为键名<br>（2） 键名所指向的对象不计入垃圾回收机制<br>如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。<br>（3）应用：都是为了避免内存泄漏</p>
<ul>
<li>DOM元素作为键，值可以为要绑定的监听事件handler，或该DOM元素对应的属性值。</li>
<li>部署class的私有属性</li>
</ul>
<h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><h3 id="1-含义"><a href="#1-含义" class="headerlink" title="1. 含义"></a>1. 含义</h3><ul>
<li>是个容器，保存异步操作</li>
<li>是个对象，有统一的API处理异步操作，获取异步操作的消息</li>
<li>对象有三种状态，除了异步操作的结果，没有别的方式能改变状态</li>
<li>一旦状态改变，就不会再变，再给Promise对象添加回调函数也会立即得到结果</li>
<li>缺点：无法取消Promise；Promise内部抛出的错误要反映到外部必须通过设置回调函数，麻烦；Pending状态不明确，无法表明是刚开始还是快完成状态。</li>
<li>Stream模式：适用于某些事件不断地反复发生的情况</li>
</ul>
<h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2. 用法"></a>2. 用法</h3><ul>
<li><p>创造实例：构造函数参数为一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; <span class="comment">//resolve和reject两个参数是js引擎提供的两个函数，不用自己部署</span></div><div class="line">  <span class="comment">// ... some code</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</div><div class="line">    resolve(value); <span class="comment">//resolve函数作用：将Promise实例的状态变为Resolved，并将异步操作成功执行的结果作为参数value传出去</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    reject(error);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>用<code>then</code>指定两种状态的回调函数，两个参数分别为两个函数，第二个可选</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="comment">//resolve函数执行后，要在当前所有同步任务执行完之后才会执行这个回调函数，value是resolve函数传来的</span></div><div class="line">  <span class="comment">// success</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="comment">// failure</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</div><div class="line">  resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Resolved.'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</div><div class="line"></div><div class="line"><span class="comment">// Promise  因为Promise新建后立即执行</span></div><div class="line"><span class="comment">// Hi!    要在当前所有同步任务执行之后再执行Promise的成功回调函数</span></div><div class="line"><span class="comment">// Resolved</span></div></pre></td></tr></table></figure></p>
<ul>
<li>当一个Promise的resolve参数是另一个Promise时，后者的状态会决定前者的状态，即，前者的状态无效，前者的then函数相当于是后者的。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>) <span class="comment">//p1的状态决定了p2的状态</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">p2    <span class="comment">//p2的语句都是针对p1的</span></div><div class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result)) </div><div class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</div><div class="line"><span class="comment">// Error: fail</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-Promise-prototype-then"><a href="#3-Promise-prototype-then" class="headerlink" title="3. Promise.prototype.then()"></a>3. Promise.prototype.then()</h3><ul>
<li>定义在原型上，是Promise实例方法</li>
<li>返回的是一个新的Promise实例 =&gt; 可以链式调用另一个then方法</li>
</ul>
<h3 id="4-Promise-prototype-catch"><a href="#4-Promise-prototype-catch" class="headerlink" title="4. Promise.prototype.catch()"></a>4. Promise.prototype.catch()</h3><ul>
<li>捕获Promise对象中的异步操作抛出的错误和then方法指定的回调函数抛出的错误</li>
<li>错误具有“冒泡”性质，会一直向后传递直到被捕获为止</li>
<li>一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。</li>
<li>返回的还是一个新的Promise对象，可以调用then方法。若是这个then方法里报错就与前面的catch无关了。</li>
<li>catch里面可以再抛出错误</li>
</ul>
<h3 id="5-Promise-all"><a href="#5-Promise-all" class="headerlink" title="5.Promise.all()"></a>5.Promise.all()</h3><ul>
<li>接收数组参数，将多个Promise实例包装成一个新的Promise实例</li>
<li>所有Promise状态都变成resolved，新的Promise状态才为resolved</li>
<li>有一个Promise状态变为rejected，新的Promise状态就为rejected</li>
</ul>
<h3 id="6-Promise-race"><a href="#6-Promise-race" class="headerlink" title="6. Promise.race()"></a>6. Promise.race()</h3><ul>
<li>接收数组参数，将多个Promise实例包装成一个新的Promise实例</li>
<li>只要有一个Promise状态改变了，新的Promise状态就跟着改变</li>
</ul>
<h3 id="7-Promise-resolve-Promise-reject"><a href="#7-Promise-resolve-Promise-reject" class="headerlink" title="7. Promise.resolve(), Promise.reject()"></a>7. Promise.resolve(), Promise.reject()</h3><ul>
<li>将现有对象转为Promise对象</li>
<li>四种参数：<ul>
<li>Promise实例：返回原对象</li>
<li>thenable对象：（具有then方法的对象），转为Promise对象后立即执行其then方法</li>
<li>不是对象或不具有then方法的对象：返回状态为resolved/rejected的Promise对象</li>
<li>无参数：同第三种</li>
</ul>
</li>
<li><p>event loop: 立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//在下一轮“事件循环”开始时执行</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'three'</span>); </div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//在本轮“事件循环”结束时执行</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'two'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>); <span class="comment">//立即执行 </span></div><div class="line"></div><div class="line"><span class="comment">// one</span></div><div class="line"><span class="comment">// two</span></div><div class="line"><span class="comment">// three</span></div></pre></td></tr></table></figure>
</li>
<li><p>对比</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = &#123;</div><div class="line">  <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">// 42，这里的值是thenable对象then函数中的value</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//----------------------------------</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> thenable = &#123;</div><div class="line">  then(resolve, reject) &#123;</div><div class="line">    reject(<span class="string">'出错了'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Promise</span>.reject(thenable)</div><div class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(e === thenable) <span class="comment">// true, 这里e是thenable对象，而不是then函数中的字符串'出错了'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="8-两个有用的附加方法"><a href="#8-两个有用的附加方法" class="headerlink" title="8. 两个有用的附加方法"></a>8. 两个有用的附加方法</h3><ul>
<li>done(): 在回调链尾端，保证抛出任何可能出现的错误</li>
<li>finally(): 无论Promise对象最后状态如何，都会执行其参数回调函数。</li>
</ul>
<h3 id="9-应用"><a href="#9-应用" class="headerlink" title="9. 应用"></a>9. 应用</h3><ul>
<li><p>加载图片：一旦加载完成，状态就变化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> preloadImage = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> image = <span class="keyword">new</span> Image();</div><div class="line">    image.onload  = resolve;</div><div class="line">    image.onerror = reject;</div><div class="line">    image.src = path;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Generator函数与Promise的结合</strong></p>
</li>
</ul>
<h3 id="10-Promise-try"><a href="#10-Promise-try" class="headerlink" title="10. Promise.try()"></a>10. Promise.try()</h3><p>模拟try代码块，无论函数是否为异步操作，都用promise处理，用then方法指定下一步操作。</p>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><ul>
<li>ES6的语法糖，为了让构造对象的方式更像面向对象编程的语法</li>
<li>class中的<code>constructor</code>函数对应ES5中的构造函数</li>
<li>class的数据类型其实就是function，类本身就指向构造函数。如下Point是class定义的“类”：<br><code>Point === Point.prototype.constructor; //true</code></li>
<li>class中的函数，不写<code>function</code>关键字，用ES6简洁写法。各函数之间不用逗号</li>
<li>class中定义的方法其实都定义在类的<code>prototype</code>上。调用实例的方法也就是调用类的原型上的方法。如下，b是通过<code>new</code>创建的类B”的实例：<br><code>b.constructor === B.prototype.constructor; //true</code></li>
<li>可以用<code>Object.assign(Point.prototype, {//funcions...})</code>一次性向类添加多个方法。</li>
<li>类内部定义的所有方法都是不可枚举的</li>
<li>类的属性名、方法名，可以用方括号表达式表示</li>
</ul>
<h4 id="1-2-constructor方法"><a href="#1-2-constructor方法" class="headerlink" title="1.2 constructor方法"></a>1.2 constructor方法</h4><ul>
<li>类的默认方法。如果没有显示定义会自动添加一个空的。</li>
<li><p>可以指定返回全新的对象<code>Object.create(null)</code>，这样<code>instanceof</code>运算符的结果就不是那个类了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo</div><div class="line"><span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
<li><p>只有用<code>new</code>才能调用构造函数，不同于ES5构造函数可以直接执行不用<code>new</code></p>
</li>
</ul>
<h4 id="1-3-不存在变量提升"><a href="#1-3-不存在变量提升" class="headerlink" title="1.3 不存在变量提升"></a>1.3 不存在变量提升</h4><ul>
<li>ES6不会把class的声明提升到代码头部</li>
<li>必须先定义class再使用（包括new和被继承）</li>
<li>与继承有关，必须保证子类在父类之后定义</li>
</ul>
<h4 id="1-4-class表达式"><a href="#1-4-class表达式" class="headerlink" title="1.4 class表达式"></a>1.4 class表达式</h4><ul>
<li>如果用类表达式，而不是类声明，要注意类的最终名称是类表达式的变量名而不是class关键字后面的类名，后者只在类内部能使用，且可省略。</li>
<li><code>name</code>属性总是返回紧跟<code>class</code>关键字后面的名字</li>
<li>立即执行类 -&gt; 立即执行函数</li>
</ul>
<h4 id="1-5-私有方法的实现"><a href="#1-5-私有方法的实现" class="headerlink" title="1.5 私有方法的实现"></a>1.5 私有方法的实现</h4><ul>
<li>体现在命名上：方法名前加下划线<code>_</code>，但是这样仍能被外部访问到</li>
<li>将方法移出class，在class内使用<code>func.call(this，args)</code>来调用<code>func</code></li>
<li>利用<code>Symbol</code>值唯一性，且只能在class内部取到。将方法名用方括号内的<code>Symbol</code>值表示。</li>
</ul>
<h4 id="1-6-this的指向"><a href="#1-6-this的指向" class="headerlink" title="1.6 this的指向"></a>1.6 this的指向</h4><ul>
<li>class中的方法中的<code>this</code>默认指向类的实例，在class外面使用该方法可能会报错，因为<code>this</code>在外面指向该方法运行时的环境，这个同ES5，解决办法：<br>（1）在构造函数中绑定<code>this</code><br>（2）在构造函数中使用箭头函数<br>（3）Proxy（暂时没看）</li>
</ul>
<h4 id="1-7-严格模式"><a href="#1-7-严格模式" class="headerlink" title="1.7 严格模式"></a>1.7 严格模式</h4><ul>
<li>类和模块内部，默认是严格模式</li>
<li>ES6其实把整个语言升级到了严格模式</li>
</ul>
<h3 id="2-class的继承"><a href="#2-class的继承" class="headerlink" title="2 class的继承"></a>2 class的继承</h3><h4 id="2-1-基本用法"><a href="#2-1-基本用法" class="headerlink" title="2.1 基本用法"></a>2.1 基本用法</h4><ul>
<li><code>extends</code>关键字</li>
<li>子类必须在constructor方法中调用super方法，否则新建实例时会报错。<br>这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。<br>ES5的继承，实质是<strong>先创造子类的实例对象this</strong>，然后再将父类的方法添加到this上面（<code>Parent.apply(this)</code>）。ES6的继承机制完全不同，实质是<strong>先创造父类的实例对象this</strong>（所以必须先调用super方法），然后再用子类的构造函数修改this。</li>
<li>子类的<code>constructor</code>中，必须先调用<code>super</code>才能使用<code>this</code></li>
<li>子类的实例，用<code>instanceof</code>运算符可验证其既是子类的实例，又是父类的实例</li>
</ul>
<h4 id="2-2-类的prototype属性和proto属性"><a href="#2-2-类的prototype属性和proto属性" class="headerlink" title="2.2 类的prototype属性和proto属性"></a>2.2 类的prototype属性和<strong>proto</strong>属性</h4><ul>
<li>两条继承链：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">B.__proto__ === A <span class="comment">// true  构造函数的继承</span></div><div class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true  方法的继承</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>理解：<br>作为一个对象：子类B的原型<code>__proto__</code>是父类A；<br>作为一个构造函数：子类的原型<code>prototype</code>是父类的实例A.prototype</p>
<ul>
<li>类继承的实质：利用<code>Object.setPrototypeOf(child, parent)</code>，而该函数的实现是用<code>__proto__</code></li>
</ul>
<h4 id="2-3-extends-后面的三种特殊情况"><a href="#2-3-extends-后面的三种特殊情况" class="headerlink" title="2.3 extends 后面的三种特殊情况"></a>2.3 extends 后面的三种特殊情况</h4><ul>
<li><p><code>class A extends Object</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A.__proto__ === <span class="built_in">Object</span>; <span class="comment">//true</span></div><div class="line">A.prototype.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
<li><p>不写继承，则A是一个普通函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">//true</span></div><div class="line">A.prototype.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>class A extends null</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">//true</span></div><div class="line">A.prototype.__proto__ === <span class="literal">undefined</span>; <span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-4-Object-getPrototypeOf"><a href="#2-4-Object-getPrototypeOf" class="headerlink" title="2.4 Object.getPrototypeOf()"></a>2.4 <code>Object.getPrototypeOf()</code></h4><p>从子类获取父类。可用来判断一个子类是否继承了另一个父类。<br><code>Object.getPrototypeOf(ColorPoint) === Point;</code></p>
<h4 id="2-5-super关键字"><a href="#2-5-super关键字" class="headerlink" title="2.5 super关键字"></a>2.5 super关键字</h4><ul>
<li>作为函数调用：代表父类的构造函数，子类的构造函数中必须执行一次，并且只能用于子类的构造函数中。虽然执行的是父类的构造函数，但是返回的是子类的实例（可以用<code>new.target.name</code>验证，它永远指向当前正在执行的函数）。相当于<code>Parent.prototype.constructor.call(this);</code></li>
<li>作为对象使用：指向父类的原型对象<code>Parent.prototype</code>，注意，是原型对象而不是实例。所以定义在父类实例上的方法和属性就不能通过<code>super</code>对象取到了。</li>
<li><p>作为对象使用，通过super调用父类的方法时，super会绑定子类的this。所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。但是通过super去读取这个赋值的属性时，super相当于父类的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</div><div class="line">    <span class="keyword">super</span>.x = <span class="number">3</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.x); <span class="comment">// undefined，相当于A.prototype.x</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">// 3</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</div></pre></td></tr></table></figure>
</li>
<li><p>作为对象使用，如果用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</p>
</li>
<li>作为对象使用，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象</li>
</ul>
<h4 id="2-6-实例的proto属性"><a href="#2-6-实例的proto属性" class="headerlink" title="2.6 实例的proto属性"></a>2.6 实例的<strong>proto</strong>属性</h4><p>子类实例的原型是父类实例，子类实例的原型的原型是父类实例的原型。<br><code>p2.__proto__.__proto__ === p1.__proto__;</code></p>
<h3 id="3-原生构造函数的继承"><a href="#3-原生构造函数的继承" class="headerlink" title="3. 原生构造函数的继承"></a>3. 原生构造函数的继承</h3><ul>
<li>ES5不能正确继承原生构造函数，ES6可以。=&gt; ES6可以创建原生数据结构的子类，自定制数据结构。</li>
<li>ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。</li>
<li>ES6先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。</li>
</ul>
<h3 id="4-class的getter和setter函数"><a href="#4-class的getter和setter函数" class="headerlink" title="4. class的getter和setter函数"></a>4. class的getter和setter函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">  get prop() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'getter'</span>;</div><div class="line">  &#125;</div><div class="line">  set prop(value) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'setter: '</span>+value);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</div><div class="line"></div><div class="line">inst.prop = <span class="number">123</span>;</div><div class="line"><span class="comment">// setter: 123</span></div><div class="line"></div><div class="line">inst.prop</div><div class="line"><span class="comment">// 'getter'</span></div></pre></td></tr></table></figure>
<h3 id="5-class的static方法"><a href="#5-class的static方法" class="headerlink" title="5. class的static方法"></a>5. class的static方法</h3><ul>
<li>不会被实例继承，而是直接通过类来调用。可以直接通过<code>类名.方法名</code>访问。</li>
<li>可以被子类继承</li>
<li>可以在子类中通过<code>super.方法名</code>调用</li>
</ul>
<h3 id="6-class的静态属性和实例属性"><a href="#6-class的静态属性和实例属性" class="headerlink" title="6. class的静态属性和实例属性"></a>6. class的静态属性和实例属性</h3><p>定义在实例上的属性：用<code>this.prop</code><br>定义在类上的属性为静态属性：<code>class.prop</code>，ES6规定要写在class外部，因为class内部只有静态方法，没有静态属性。但是ES7提案可以写在class内部，加上<code>static</code>关键字即可，并且Babel也支持。</p>
<h3 id="7-类的私有属性"><a href="#7-类的私有属性" class="headerlink" title="7. 类的私有属性"></a>7. 类的私有属性</h3><p>提案：<code>#</code>属性前缀</p>
<h3 id="8-new-target属性"><a href="#8-new-target属性" class="headerlink" title="8. new.target属性"></a>8. new.target属性</h3><ul>
<li>new命令的属性，用于构造函数中。</li>
<li>返回new命令作用于的构造函数。如果构造函数不是由new调用（比如通过<code>call</code>,<code>apply</code>调用）的，则该属性为<code>undefined</code>。如果是通过new调用的，返回相应的class名字或构造函数名。</li>
<li>子类构造函数中该属性指向子类。</li>
</ul>
<h3 id="9-Mixin模式"><a href="#9-Mixin模式" class="headerlink" title="9. Mixin模式"></a>9. Mixin模式</h3><p>通过继承<code>mix</code>类，将多个类合成一个类：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DistributedEdit</span> <span class="keyword">extends</span> <span class="title">mix</span>(<span class="title">Class1</span>, <span class="title">Class2</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Module语法"><a href="#Module语法" class="headerlink" title="Module语法"></a>Module语法</h2><h3 id="1-为什么要引入Module"><a href="#1-为什么要引入Module" class="headerlink" title="1. 为什么要引入Module"></a>1. 为什么要引入Module</h3><ul>
<li>CommonJS和AMD，都是运行时确定模块之间的依赖关系。“运行时加载”：整体加载某个模块，加载其所有方法，生成一个对象，然后从该对象中读取所需的几个方法。运行时才获取该对象，无法在编译时做“静态优化”。<br>ES6提出的解决方案，更加静态化。</li>
<li><p>ES6编译时加载（静态加载），之加载需要的某几个方法，可以在编译时就加载完成，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CommonJS模块</span></div><div class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="comment">// ES6模块</span></div><div class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>ES6好处：<br>1）效率更高；<br>2）可以静态分析，拓宽js语法（宏Macro， 类型检验）<br>3）浏览器、服务器端都支持，不再需要UMD<br>4）将来浏览器新的API可通过模块格式提供，不再需要做成全局变量或<code>navigator</code>对象的属性<br>5）不再需要对象作为命名空间（比如<code>Math</code>对象），而是通过模块格式提供</p>
</li>
</ul>
<h3 id="2-严格模式"><a href="#2-严格模式" class="headerlink" title="2. 严格模式"></a>2. 严格模式</h3><p>ES6模块自动采用严格模式</p>
<h3 id="3-export-amp-import"><a href="#3-export-amp-import" class="headerlink" title="3. export &amp; import"></a>3. export &amp; import</h3><p><code>var, function, class</code>都可以export<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// 写法二</span></div><div class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</div><div class="line"><span class="keyword">export</span> &#123;m&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 写法三</span></div><div class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</div><div class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</div></pre></td></tr></table></figure></p>
<p>CommonJS 模块输出的是值的缓存，不存在动态更新。而ES6输出的值会动态更新。</p>
<p><code>export</code>和<code>import</code>不能出现在块级作用域内，可以出现在模块顶层的任何位置。</p>
<p><code>import</code>的写法和<code>export</code>基本相同。<code>import { ... } from &#39;&#39;</code>后面的路径可以是相对或绝对的，可以省略<code>.js</code>，如果配置文件中配置过的话。<code>import * as circle from &#39;./circle&#39;</code>模块的整体加载。加载的对象不可以修改其属性和方法，因为不允许运行时改变。<code>import moduleA；</code>只执行模块，不引入任何变量。</p>
<p><code>import</code>有变量提升效果，在编译阶段（代码运行前）执行，静态执行，所以不能用表达式和变量。</p>
<p><code>import</code>语句是 Singleton 模式。如果多次加载同一个模块，对应的也是同一个对象。</p>
<h3 id="4-export-default命令"><a href="#4-export-default命令" class="headerlink" title="4. export default命令"></a>4. export default命令</h3><ul>
<li>使用模块要先知道模块中输出了哪些东西，才好指定<code>import</code>具体引入哪些东西。</li>
<li>默认输出的函数，在<code>import</code>时不用大括号，可以为这个默认引入的函数指定任意名字调用。</li>
<li>该命令一个模块只能使用一次，因为一个模块只能指定一个默认输出，所以<code>import</code>才不用大括号。</li>
<li>后面不能跟变量赋值语句，可以跟变量。因为默认输出变量<code>default</code>，跟着变量则将该变量赋值给<code>default</code>变量。</li>
<li><code>export</code>和<code>import</code>结合</li>
<li>具名接口和默认接口互相改变。</li>
</ul>
<h3 id="5-跨模块常量"><a href="#5-跨模块常量" class="headerlink" title="5. 跨模块常量"></a>5. 跨模块常量</h3><p><code>const</code>声明的常量只在当前模块有效，不能跨模块获取到。解决办法：<br>将不同模块放在同一目录下，再将这些模块引入到一个文件里，最后只需要引入这个文件即可。</p>
<h3 id="6-动态加载提案：import"><a href="#6-动态加载提案：import" class="headerlink" title="6. 动态加载提案：import()"></a>6. 动态加载提案：<code>import()</code></h3><ul>
<li>类似于Node的<code>require</code>，运行时加载。<code>import()</code>是异步加载，<code>require()</code>是同步加载。</li>
<li>返回Promise对象。</li>
<li>按需加载，条件加载，加载动态生成路径。</li>
</ul>
<h2 id="Module的加载实现"><a href="#Module的加载实现" class="headerlink" title="Module的加载实现"></a>Module的加载实现</h2><h3 id="1-浏览器加载"><a href="#1-浏览器加载" class="headerlink" title="1. 浏览器加载"></a>1. 浏览器加载</h3><ul>
<li>传统方法：</li>
</ul>
<p>同步加载。浏览器的渲染引擎遇到<code>&lt;script&gt;</code>标签就停下来，先执行脚本（如果是外部脚本，还要先下载），然后再继续渲染。</p>
<p>异步加载：<code>defer</code>或<code>async</code>：遇到<code>&lt;script&gt;</code>先下载，暂不执行。前者要等到整个页面正常渲染结束，才会执行，（先渲染，后执行，多个有序）；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染（仅仅是下载不阻塞，但下载完就执行，多个不一定有序）。</p>
<ul>
<li>浏览器加载ES6模块：<code>&lt;script type=&quot;module&quot; src=&quot;&quot;&gt;</code>或<code>&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;</code>，异步加载。默认渲染完再执行（同<code>defer</code>），也可设置为<code>async</code></li>
</ul>
<h3 id="2-ES6模块与CommonJS模块的差别"><a href="#2-ES6模块与CommonJS模块的差别" class="headerlink" title="2. ES6模块与CommonJS模块的差别"></a>2. ES6模块与CommonJS模块的差别</h3><ul>
<li>CommonJS 模块输出的是一个值的拷贝（将加载执行后的值缓存了），ES6 模块输出的是值的引用（在静态分析时生成该值的<strong>只读</strong>（不可以重新赋值）引用，等脚本真正执行时才去模块里根据引用去取值）。所以ES6输出的会随模块内部相应值动态更新而CommonJS不会。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>
</ul>
<h3 id="3-Node加载"><a href="#3-Node加载" class="headerlink" title="3. Node加载"></a>3. Node加载</h3><ul>
<li>Node加载ES6模块和CommonJS模块是分开的，只要有<code>import</code>或<code>export</code>就认为是ES6模块，否则就为CommonJS模块。</li>
<li>ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块</li>
<li><p>加载规则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'./foo'</span>;</div><div class="line"><span class="comment">// 依次寻找</span></div><div class="line"><span class="comment">//   ./foo.js</span></div><div class="line"><span class="comment">//   ./foo/package.json</span></div><div class="line"><span class="comment">//   ./foo/index.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">'baz'</span>;</div><div class="line"><span class="comment">// 依次寻找</span></div><div class="line"><span class="comment">//   ./node_modules/baz.js</span></div><div class="line"><span class="comment">//   ./node_modules/baz/package.json</span></div><div class="line"><span class="comment">//   ./node_modules/baz/index.js</span></div><div class="line"><span class="comment">// 寻找上一级目录</span></div><div class="line"><span class="comment">//   ../node_modules/baz.js</span></div><div class="line"><span class="comment">//   ../node_modules/baz/package.json</span></div><div class="line"><span class="comment">//   ../node_modules/baz/index.js</span></div><div class="line"><span class="comment">// 再上一级目录</span></div></pre></td></tr></table></figure>
</li>
<li><p>交叉命令加载：</p>
<ul>
<li>用<code>import</code>加载CommonJS模块：将CommonJS模块的<code>module.exports</code>视作<code>export default</code>。采用<code>import...as bar from &#39;&#39;</code>的写法时，要通过<code>bar.default</code>拿到模块的默认输出。加载的模块仍具有CommonJS特性（运行时加载，输出值的拷贝缓存机制），不允许大括号语法。</li>
<li>用<code>require</code>加载ES6模块：模块的所有输出值都为<code>require</code>的赋值对象的属性。采用这种方式引入ES6模块也是缓存机制，不能动态更新值。</li>
</ul>
</li>
</ul>
<h3 id="4-循环加载"><a href="#4-循环加载" class="headerlink" title="4. 循环加载"></a>4. 循环加载</h3><p>CommonJS：同步加载，按照代码顺序执行每个模块，加载时停在这里等它执行完毕才会执行后面的代码。每个模块只会加载一次，如果遇到循环加载，要看该模块有没有被执行过或正在执行中。<br>ES6：引入的是引用，后期可以根据引用去相应模块中取值。</p>
<h3 id="5-另外两种ES6转码器"><a href="#5-另外两种ES6转码器" class="headerlink" title="5. 另外两种ES6转码器"></a>5. 另外两种ES6转码器</h3><p>ES6 module transpiler：npm包，es6-module-transpiler<br>SystemJS: 其实调用了Google的Traceur转码器。<code>&lt;scripts src=&quot;system.js&quot;&gt;</code>标签引入该垫片库（polyfill），用<code>System.import(&#39;&#39;)</code>，异步加载，返回一个Promise</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/10/《React-引领未来的用户界面框架》读书笔记/" rel="next" title="《React:引领未来的用户界面框架》读书笔记">
                <i class="fa fa-chevron-left"></i> 《React:引领未来的用户界面框架》读书笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/18/Data-Structure-JS/" rel="prev" title="Data Structure(JS)">
                Data Structure(JS) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!--MOB SHARE BEGIN-->
<div class="-mob-share-ui-button -mob-share-open">分享</div>
<div class="-mob-share-ui -mob-share-ui-theme  -mob-share-ui-theme-slide-bottom" style="display: none">
    <ul class="-mob-share-list">
        <li class="-mob-share-weibo"><p>新浪微博</p></li>
        <li class="-mob-share-weixin"><p>微信</p></li>
        <li class="-mob-share-youdao"><p>有道云笔记</p></li>
        <li class="-mob-share-pocket"><p>Pocket</p></li>
        <li class="-mob-share-facebook"><p>Facebook</p></li>
        <li class="-mob-share-twitter"><p>Twitter</p></li>
    </ul>
    <div class="-mob-share-close">取消</div>
</div>
<div class="-mob-share-ui-bg"></div>
<script id="-mob-share" src="https://f1.webshare.mob.com/code/mob-share.js?appkey=1e2b5a54b350d"></script>
<!--MOB SHARE END-->


      
  </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/upload/image/zxy.jpeg"
               alt="Zhang Xinyu" />
          <p class="site-author-name" itemprop="name">Zhang Xinyu</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

          
            <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
            <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
            <div class="widget-wrap">
                <h3 class="widget-title">Tag Cloud</h3>
                <div id="myCanvasContainer" class="widget tagcloud">
                    <canvas width="250" height="250" id="resCanvas" style="width=100%">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OAuth2/">OAuth2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a><span class="tag-list-count">1</span></li></ul>
                    </canvas>
                </div>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/helloworldzxy" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/helloworldzxy" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


           <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=67528&auto=0&height=66"></iframe>


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6语法"><span class="nav-text">ES6语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#let-amp-const命令"><span class="nav-text">let & const命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-let命令"><span class="nav-text">1. let命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-基本用法"><span class="nav-text">1.1 基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-不存在变量提升"><span class="nav-text">1.2 不存在变量提升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-暂时性死区-TDZ-Temporal-Dead-Zone"><span class="nav-text">1.3 暂时性死区(TDZ, Temporal Dead Zone)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-不允许重复声明"><span class="nav-text">1.4 不允许重复声明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-块级作用域"><span class="nav-text">2. 块级作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-为什么需要块级作用域"><span class="nav-text">2.1 为什么需要块级作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-let为ES6新增块级作用域"><span class="nav-text">2.2 let为ES6新增块级作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-关于在块级作用域内声明函数"><span class="nav-text">2.3 关于在块级作用域内声明函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-do表达式"><span class="nav-text">2.4 do表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-const命令"><span class="nav-text">3. const命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-基本用法"><span class="nav-text">3.1 基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-本质"><span class="nav-text">3.2 本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-ES6声明变量有六种方法："><span class="nav-text">3.3 ES6声明变量有六种方法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-global对象"><span class="nav-text">5. global对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量的解构赋值"><span class="nav-text">变量的解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-数组解构赋值"><span class="nav-text">1. 数组解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-字符串解构赋值"><span class="nav-text">3. 字符串解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-数值和布尔值的解构赋值"><span class="nav-text">4. 数值和布尔值的解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-函数参数的解构赋值"><span class="nav-text">5. 函数参数的解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-圆括号问题"><span class="nav-text">6. 圆括号问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-解构赋值的用途"><span class="nav-text">7. 解构赋值的用途</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串的扩展"><span class="nav-text">字符串的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-字符串的Unicode表示法"><span class="nav-text">1. 字符串的Unicode表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-codePointAt-index-对应于charAt-index"><span class="nav-text">2. codePointAt(index) 对应于charAt(index)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-String-fromCodePoint-codePoint-对应于fromCharCode-codePoint"><span class="nav-text">2. String.fromCodePoint(codePoint) 对应于fromCharCode(codePoint)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-at-index-对应于charAt-index"><span class="nav-text">3. at(index) 对应于charAt(index)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-normalize"><span class="nav-text">4. normalize()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-includes-startsWith-endsWith"><span class="nav-text">5. includes(), startsWith(), endsWith()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-repeat"><span class="nav-text">6. repeat()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-padStart-padEnd"><span class="nav-text">7. padStart(), padEnd()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-模板字符串"><span class="nav-text">8. 模板字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的扩展"><span class="nav-text">数组的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Array-from"><span class="nav-text">1. Array.from()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Array-of"><span class="nav-text">2.Array.of()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-数组实例方法copyWithin"><span class="nav-text">3. 数组实例方法copyWithin()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-数组实例方法find-和findIndex"><span class="nav-text">4. 数组实例方法find()和findIndex()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-数组实例方法fill"><span class="nav-text">5. 数组实例方法fill()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-数组实例方法entries-keys-values"><span class="nav-text">6. 数组实例方法entries(), keys(), values()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-数组实例方法includes"><span class="nav-text">7. 数组实例方法includes()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-数组的空位"><span class="nav-text">8. 数组的空位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的扩展"><span class="nav-text">函数的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-函数的默认值"><span class="nav-text">1. 函数的默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-rest参数"><span class="nav-text">2. rest参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-扩展运算符"><span class="nav-text">3. 扩展运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-严格模式"><span class="nav-text">4. 严格模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-name属性"><span class="nav-text">5. name属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-箭头函数"><span class="nav-text">6. 箭头函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-绑定this"><span class="nav-text">7. 绑定this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-尾调用优化-（-好难…）"><span class="nav-text">8. 尾调用优化 （*好难…）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-尾逗号"><span class="nav-text">9. 尾逗号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的扩展"><span class="nav-text">对象的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-属性的简洁表示法"><span class="nav-text">1. 属性的简洁表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-属性名表达式"><span class="nav-text">2. 属性名表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-方法的name属性"><span class="nav-text">3. 方法的name属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Object-is"><span class="nav-text">4. Object.is()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Object-assign-target-source1-source2"><span class="nav-text">5. Object.assign(target, source1, source2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-属性的可枚举性"><span class="nav-text">6. 属性的可枚举性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-属性的遍历"><span class="nav-text">7. 属性的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-设置-读取原型对象"><span class="nav-text">8. 设置/读取原型对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Object-keys-遍历补充"><span class="nav-text">9.Object.keys()遍历补充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-对象的扩展运算符"><span class="nav-text">10. 对象的扩展运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-Object-getOwnPropertyDescriptor"><span class="nav-text">11. Object.getOwnPropertyDescriptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-Null传导运算符"><span class="nav-text">12. Null传导运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set-和-Map-数据结构"><span class="nav-text">Set 和 Map 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Set"><span class="nav-text">1. Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-WeakSet"><span class="nav-text">2. WeakSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Map"><span class="nav-text">3. Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-WeakMap"><span class="nav-text">4. WeakMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise对象"><span class="nav-text">Promise对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-含义"><span class="nav-text">1. 含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-用法"><span class="nav-text">2. 用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Promise-prototype-then"><span class="nav-text">3. Promise.prototype.then()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Promise-prototype-catch"><span class="nav-text">4. Promise.prototype.catch()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Promise-all"><span class="nav-text">5.Promise.all()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Promise-race"><span class="nav-text">6. Promise.race()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Promise-resolve-Promise-reject"><span class="nav-text">7. Promise.resolve(), Promise.reject()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-两个有用的附加方法"><span class="nav-text">8. 两个有用的附加方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-应用"><span class="nav-text">9. 应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Promise-try"><span class="nav-text">10. Promise.try()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class"><span class="nav-text">Class</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-基本语法"><span class="nav-text">1. 基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-概述"><span class="nav-text">1.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-constructor方法"><span class="nav-text">1.2 constructor方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-不存在变量提升"><span class="nav-text">1.3 不存在变量提升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-class表达式"><span class="nav-text">1.4 class表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-私有方法的实现"><span class="nav-text">1.5 私有方法的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-this的指向"><span class="nav-text">1.6 this的指向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-严格模式"><span class="nav-text">1.7 严格模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-class的继承"><span class="nav-text">2 class的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-基本用法"><span class="nav-text">2.1 基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-类的prototype属性和proto属性"><span class="nav-text">2.2 类的prototype属性和proto属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-extends-后面的三种特殊情况"><span class="nav-text">2.3 extends 后面的三种特殊情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-Object-getPrototypeOf"><span class="nav-text">2.4 Object.getPrototypeOf()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-super关键字"><span class="nav-text">2.5 super关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-实例的proto属性"><span class="nav-text">2.6 实例的proto属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-原生构造函数的继承"><span class="nav-text">3. 原生构造函数的继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-class的getter和setter函数"><span class="nav-text">4. class的getter和setter函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-class的static方法"><span class="nav-text">5. class的static方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-class的静态属性和实例属性"><span class="nav-text">6. class的静态属性和实例属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-类的私有属性"><span class="nav-text">7. 类的私有属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-new-target属性"><span class="nav-text">8. new.target属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Mixin模式"><span class="nav-text">9. Mixin模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Module语法"><span class="nav-text">Module语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-为什么要引入Module"><span class="nav-text">1. 为什么要引入Module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-严格模式"><span class="nav-text">2. 严格模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-export-amp-import"><span class="nav-text">3. export & import</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-export-default命令"><span class="nav-text">4. export default命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-跨模块常量"><span class="nav-text">5. 跨模块常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-动态加载提案：import"><span class="nav-text">6. 动态加载提案：import()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Module的加载实现"><span class="nav-text">Module的加载实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-浏览器加载"><span class="nav-text">1. 浏览器加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-ES6模块与CommonJS模块的差别"><span class="nav-text">2. ES6模块与CommonJS模块的差别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Node加载"><span class="nav-text">3. Node加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-循环加载"><span class="nav-text">4. 循环加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-另外两种ES6转码器"><span class="nav-text">5. 另外两种ES6转码器</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Xinyu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    访客量 <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    访问次数 <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "b2e1b88c083a42509d36899dc89eb8d9",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("f1ufW13qlGddew5inanKJ79a-gzGzoHsz", "dp1rMt2iMERlKRjnbPKoly3b");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

</body>
</html>
